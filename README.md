# Tauri vs Electron framework
## Introduction
Tauri and Electron are both frameworks for creating desktop applications using web technologies to develop the applications' user interface. Although at first glance one might think that the frameworks are similar, there are fundamental differences that clearly distinguish them.

We will first see the differences between two builds generated by these frameworks, and then we will try to explain these differences by studying how they work.

## Testing environment

We will create new React app with CRA (create-react-app) 4.0.3 consisting on a simple file explorer. At the top of the page we will have the display of the current folder and an icon allowing to go to the parent folder. The main part of the application will simply display the files and folders in the current folder.

We will use several npm package to achieve this :
- [MUI framework 5.0.6](https://mui.com/) which provides material UI components
- [SASS 1.43.4](https://github.com/sass/dart-sass) to allow to use and import scss files

![screenshot](resources/screenshot.png)

The main UI component will consume a service named File.js which will provide the contents of a specifided folder path :
```javascript
export function getFolderContent(path) {
	// implementation will change depending the framework (electron node API vs tauri API)
});
```

The two projects share the exact same react components, only the implementation of the File.js service will be different. It will use either the node JS API or the tauri API.

## Test results
### Bundle size
| Framework | OS | Bundle size (installer)  | Main executable size |
|--|--|--|--|
| Electron  15.3.0 | Windows 11 x64 | 83 MB | 137 MB|
| Tauri 1.0.0-beta.10 | Windows 11 x64 | 7MB | 4MB |
| Electron  15.3.0 | Linux x64 | 114 MB (deb) | 134 MB|
| Tauri 1.0.0-beta.10 | Linux x64 | 6.5 MB (deb) | 16 MB |

### Memory consumption
| Framework | OS | Number of processes | Total RAM used  |
|--|--|--|--|
| Electron  15.3.0 | Windows 11 |4| 138 MB | 
| Tauri 1.0.0-beta.10 | Windows 11 |8| 110 MB | 
| Electron  15.3.0 | Linux x64 | 18 | 224 MB|
| Tauri 1.0.0-beta.10 | Linux x64 | 1 | 23 MB |

### Executable launch speed 
| Framework | OS | First launch after build | Second launch | 
|--|--|--|--|
| Electron  15.3.0 | Windows 11 | 9940 ms | 1420 ms | 
| Tauri 1.0.0-beta.10 | Windows 11 | 1230 ms | 1120 ms | 
| Electron  15.3.0 | Linux x64 | 2570 ms | 1910 ms|
| Tauri 1.0.0-beta.10 | Linux x64 | 1560 ms | 1130 ms |

## Interpretation of results

As we can see, the tauri bundle is up to 19 times smaller than the electron one. This can be explained by the fact that tauri uses the web browser provided by the operating system, while electron embed chromium in its bundle.

The memory usage is also up to 9 times higher with electron. Tauri uses a rust backend, which is way ligther and faster than the node.js runtime used by Electron and embedded in the bundle. Morever, electron launches several javascript instances at the same time, which increases also the memory usage.

Since electron provides access to the entire node.JS API, developers will have access to everything they need to develop their application using only JavaScript. In contrast, the tauri API is much less complete and fleshed out than Node.JS, which will mean developing the missing functionality in Rust. The development team must know how to develop in Rust if the need is particularly specific.

Example: fs.readDir() allows to access only the name and absolute path of files in a folder. If you want to have more information about the files (permissions, creation date...) you will have to develop the rust function which will return this information.

## Conclusion

Although Tauri allows to get a lighter and faster binary than Electron, the features offered by the API are very basic and you will probably have to develop in Rust the missing features. The fact that tauri uses the browser embedded by the operating system implies that you have to make the application compatible with multiple browsers (Edge, safari..).

Moreover, tauri is currently still in beta testing, and should not be used for large-scale projects in production mode.
